# Linux高性能服务器编程笔记

## 第一篇 tcp/ip协议详解

tcp/ip分层下，数据链路层，网络层，传输层协议是在内核实现。因此操作系统需要实现一组系统调用，使得应用程序能够访问这些协议提供的服务。
实现这组系统调用的API主要有两套：socket和XTI

无连接：指通信双方都不长久地维持对方的任何消息

IP层传递给数据链路层的数据可能是一个完整的IP数据报，也可能是一个IP分片，它们统称为IP分组（packet）

TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁

TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重启定时器。

TCP拥塞控制：提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。
拥塞控制的四个部分：

- 慢启动（slow start）
- 拥塞避免（congestion avoidance）
- 快速重传（fast retransmit）
- 快速恢复（fast recovery）

拥塞控制算法：reno算法，vegas算法，cubic算法

## 第二篇 深入解析高性能服务器编程

字节序分为：大端字节序和小端字节序，网络传输时总是采用大端字节序

在UNIX/Linux中，socket就是可读，可写，可控制，可关闭的文件描述符。

使用socket

1. 创建socket
2. 命名socket（将socket与socket地址绑定）
3. 监听socket
4. 接受连接（accept成功时返回一个新的连接socket）
5. 发起连接
6. 关闭连接
7. 数据读写

守护进程（daemon）的父进程通常是init进程（PID为1的进程）

服务器的三个主要模块：

- I/O处理单元
- 逻辑单元
- 存储单元

阻塞I/O ： 执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止
非阻塞I/O ： 执行的系统调用总是立即返回，而不管事件是否已经发生

I/O复用 ： 是一种I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知应用程序。I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力

Linux下实现I/O复用的系统调用主要有select，poll和epoll

同步I/O模型与异步I/O模型

- 同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，获将数据从用户缓冲区写入内核缓冲区，同步I/O向应用程序通知的是I/O就绪事件）
- 异步I/O模型则由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的，异步I/O向应用程序通知的是I/O完成事件）

服务器通常需要处理三类事件：I/O事件，信号，定时事件（通常会使用I/O复用系统调用来统一事件源）

两种高效的事件处理模式：Reactor和Proactor

Reactor模式： 要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。并发编程主要有多进程和多线程两种方式。

并发编程模式：半同步/半异步模式（I/O处理单元为异步，逻辑工作单元为同步），领导者/追随者模式
在并发模式中，“同步”的概念与I/O不同。“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断，信号等。

高效的逻辑处理方式：有限状态机

信号是由用户，系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。

Linux下I/O多路复用系统调用：select，poll，epoll

### 进程

#### fork系统调用 ： 创建新进程

该函数的每次调用都返回两次，在父进程中返回的是子进程的PID，在子进程中则返回0。
fork函数复制当前进程，在内核进程表中创建一个新的进程表项。
新的进程表项有很多属性和原进程相同，比如堆指针，栈指针和标志寄存器的的值。
但也有许多属性被赋予了新的值
子进程的代码与父进程完全相同，同时它还会复制父进程的数据（堆数据，栈数据和静态数据）。数据的复制采用的是写时复制
创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加一。

#### exec系列系统调用

如果执行没出错，则原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）

#### 僵尸进程

对于多进程程序而言，父进程一般需要跟踪子进程的推出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程推出信息的查询（如果父进程还在运行）
在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。

当一个进程结束时，它将给其父进程发送一个SIGCHILD信号

### IPC(Inter-Process Communication,进程间通信) ： 信号量，共享内存，消息队列

#### 信号量

信号量用于解决并发的问题

信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待（wait）和信号（signal）。（不过在Linux/UNIX中，“等待”和“信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P（荷兰单词passeren，传递，就好像进入临界区），V操作（释放，就好像退出临界区））。

假设有信号量SV，则对它的P，V操作含义如下：
1.P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行
2.V(SV),如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1

信号量的取值可以是任何自然数。但最常用的，最简单的信号量是二进制信号量，它只能取0和1这两个值。

Linux中的信号量api : semget,semop,semctl

#### 共享内存

Linux中的共享内存api ： shmget，shmat，shmdt，shmctl

#### 消息队列

Linux中的消息队列api ： msgget，msgsnd，msgrcv和msgctl

### 线程

POSIX线程同步方式 ： POSIX信号量，互斥锁（mutex），条件变量

根据运行环境和调度者的身份，线程可分为内核线程和用户线程
1.内核线程：运行在内核空间，由内核来调度
2.用户线程：运行在用户空间，由线程库来调度

内核线程相当于用户线程运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程。

竞态条件（race condition）：如果程序运行顺序的改变会影响最终结果，那么这就是一个竞态条件

若一个多线程程序的某个线程调用了fork函数，那么新创建的子进程不会自动创建父进程相同数量的线程，子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父进程中互斥锁（条件变量与之类似）的状态。

## 系统检测工具

- tcpdump:网络抓包工具
- nc
- strace
- lsof：理出当前系统打开的文件描述符的工具
- netstat
- vmstat
- ifstat
- mpstat

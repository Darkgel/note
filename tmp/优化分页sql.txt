优化分页sql
	1.先获取主键，然后根据主键来获取记录
		SELECT
		*
		FROM table
		JOIN
		(select id from table
		where condition1 = 0
		and condition2 = 0
		and condition3 = -1
		and condition4 = -1
		order by id asc
		LIMIT 2000 OFFSET 50000)
		as tmp using(id)

		或者

		SELECT a.* FROM table a, 
		(select id from table
		where condition1 = 0
		and condition2 = 0
		and condition3 = -1
		and condition4 = -1
		order by id asc
		LIMIT 2000 OFFSET 50000) b 
		where a.id = b.id
	2.利用主键索引，使用 >=  (先查出偏移后的主键，再根据主键索引查询数据块的所有内容即可优化)
		Select * From yanxue8_visit Where vid ＞=
		( Select vid From yanxue8_visit Order By vid limit 10000,1 ) 
		limit 10 
	分页优化思路
	1.使用索引（解决 WHERE）
	2.在排序时使用和1中同样的索引 (解决 ORDER)
	3.


注意区分Binary tree 和 B-tree（或 B tree）；后者的B指Balance
注意区分Binary tree 和Binary search tree(后者是经过排序处理的)
平衡树
B-树
B+树

B树（B-树     self-balancing tree data structure ）
	order（相当于最大出度） 为 m 的B-树（Knuth's 的定义）
	1.每个节点最多有m个子节点
	2.每个非叶子节点（除了根节点）最少有[m/2]个子节点
	3.如果一个根节点不是叶节点的话，它至少要有2个子节点
	4.非叶子节点包含k个子节点和k-1个keys
	5.所有的叶子节点出现在同一层
	。。。（还有左边为小，右边为大等等）



	B树是在二叉搜索树的基础上进行泛化得到的（即可以有多于两个以上的子节点）
	不同于Self-balancing binary search tree，B树是基于按块（block）进行数据读写来优化的(因此通常用于数据库和文件系统)
	在实现中，通常会限制子节点的数量，因此衍生出了2-3 B-tree (即2-3 tree)

	非叶子节点
		组成： （key，pointer）       count(pointer) = count(key) + 1 
		key 会进行排序
		不同的节点不会包含相同的key
		通常非叶子节点中key的数量介于d~2d（d为key数量的最小值，而d+1为最小的度）(2d中因子2的选择是为了确保节点可以分裂或聚合)

		在插入或删除数据的时候，会造成节点的分裂或聚合（但相对于Self-balancing binary search tree，重新平衡的频率会小很多,但相对的，可能会多消耗空间）
		但插入数据后节点中的key个数为2d+1时，该节点分裂为两个包含d个key的节点，然后位于2d+1个key中排序为中间的key上升到父节点
		但从key个数为d的节点删除key的时候，会发生节点的聚合

	叶子节点
		与非叶子节点类似，只是不再有子节点
		注意： 并不要求把所有的key记录在子节点中

	2-3 tree （非叶子节点储存1个key（2个子节点）或2个key(3个子节点)）


	查找： 类二叉查找树
	插入： 
		先查找所有的叶子节点，找到当前值应该插入的位置，然后一级一级往上递归（如果有分裂的话）
		有一种优化的插入算法是从根节点开始的
	删除
		1.定位到节点，删除，然后重构树
		2.？？？从上到下定位，但在访问之前，先重构树

		使用1策略删除时会遇到以下这些情况：
		1.即将要删除的可以是这个节点的边缘key
		2.删除key时会导致聚合

B+树
	B-树的变体


为什么在数据库中采用B-树
	1.数据库大多数是基于磁盘驱动的
	2.从磁盘读取一条数据的时间远远大于进行一次key比较的时间
	3.因此应该减少从磁盘读取数据的次数
	4.如何提高性能：(block等价于B-树中的节点)
		 使用索引，在索引中包含每一个disk block的第一条记录
		 假设一个block包含100条记录，则这个索引的大小是原总数据大小的百分之一
		 通过搜索索引，我们可以知道具体去哪个block上找相应的record
		 总结： 因为索引的总大小远远小于总数据的大小，所以我们可以通过更少的磁盘读写次数遍历完索引，得到记录的具体block后只需要再加一次磁盘读写次数就可以读到所查找的记录了
	5.如果在数据上建了一次索引还不够，那么可以继续在索引上建索引，以此类推

	例子： 
	有10000条record
	每个block可以存100record或100条index entry
	每个index entry即其所在block的第一条数据

	假设最坏情况： 
		在不使用索引的情况下：
			需要100次磁盘读写才能找到
		在使用record的情况下：
			10000条record需要100条index entry（只需要一个block即可存满）
			先从磁盘读出索引block（第一次磁盘读操作）
			然后从索引中比较找到entry
			根据entry直接读取目标block，通过比较找到目标数据（第二次磁盘读操作）


	在使用索引的情况下进行删除
		可以直接把record标记为deleted，索引不变。（但如果有大量的删除操作，那么索引的作用将降低）
	在使用索引的情况下进行添加
		因为添加的性能非常差，所以常见的方法是：在block预留一些地方用于后续添加，而非填满；当删除数据时，留下的位置也同样可以用于添加
		如果实在在当前block找不到位置，那么就不得不添加到别的block，然后修改索引

	总结（B-树作为数据库索引的优势）：
	1.有序的key便于顺序遍历
	2.使用了多层次的索引结果来减少磁盘读写次数
	3.为了提高插入和删除的效率只局部地使用了block的全部空间
	4.通过递归算法保持索引的平衡
	5.通过确保节点的key大于d来减少浪费


B+树
	与B-树的区别：
		在B-树的子节点下添加了一层





mysql  index
	B-Tree
		索引对多个值的进行排序的依据是定义索引时列的顺序
		B-Tree索引对如下类型的查询有效：
			1.全值匹配： 和索引中的所有列进行匹配
			2.匹配最左前缀 : 匹配索引(i0)或(i0,i1)或(i0,i1,i2)...
			3.匹配列前缀 : 只匹配某一列的值的开头部分。（eg： 查找所有以J开头的姓的人）
			4.匹配范围值 
			5.精确匹配某一列并范围匹配另外一列
			6.只访问索引的查询

		因为索引树中的节点是有序的，所以用于查询外，还可以用于排序（一般来说，某个索引如果可以用于查询那么也可以用于排序）、分组(Group by)
		因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询

		B-Tree索引的一些限制：
			1.如果不是按照索引的最左列开始查找，则无法使用索引
			2.不能跳过索引中的列，即建立了索引（a，b，c）时，无法使用索引（a，c）（此时只能使用索引（a））
			3.如果查询中有某个列的范围，则其右边的所有列都无法使用索引优化查找
				（eg ： where last_name='Smith' and first_name like 'J%' and dob='1976-12-23',这个查询只能使用索引的前两列，因为Like 是一个范围条件。因此，如果范围查询列的数量有限，那么可以通过使用多个等于条件来替代）

		设计索引的时候要注意索引列的顺序

		在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求



	哈希索引
		只有精确匹配索引所有列的查询才有效(因为对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码；如果多个列的哈希值相同，用拉链法解决)

		哈希索引的一些限制（因为以下这些限制，哈希索引只适合某些特定场合）： 
			1.哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
			2.哈希索引数据并不是按照索引值顺序存储的，无法用于排序
			3.不支持部分索引列匹配查找，必须使用全部索引列
			4.只支持等值比较（=，in，<=>）
			5.当出现很多哈希冲突时，需要遍历链表
			6.在哈希冲突比较多的情况下，一些索引维护的代价也会很高（当从表中删除一行时，需要遍历链表中的每一行，找到并删除对应行的引用）

		伪哈希索引使用建议：
			问题：存储大量的url，并需要根据url进行搜索查找（如果使用B-Tree来存储url，存储的内容会很大，因为url本身都很长）
			解决方法： 
				select id from url where url='xxx' and url_crc=CRC32('xxx')；
				在url_crc字段上使用B-Tree索引
				同时可以使用触发器来维护数据的插入和更新

	空间数据所以(R-Tree)
		mysql中目前并不完善

	全文索引
		查找的是文本中的关键词，而不是直接比较索引中的值
		全文索引与其他基类索引的匹配方式完全不一样，其更类似于搜索引擎，而非简单的Where条件匹配



索引时最好的解决方案吗？
	对于非常小的表，大部分情况下简单的全表扫描更高效
	对于中到大型的表，索引就非常有效
	对于特大型的表，建立和使用索引的代价将随之增长（此时可以考虑使用分区技术）
	如果表的数量非常多，可以建立一个元数据信息表
	对于TB级别的数据，定位单条记录的意义不大，所以经常会使用块级别元数据技术来替代索引


索引质量标准：
	1.一星：索引将相关的记录放到一起
	2.二星：索引中的数据顺序和查找中的排列顺序一致
	3.三星：索引中的列包含了查询中需要的全部列


高性能的索引策略
	索引的建立依据来源于查询，而建立了索引后，在开发中构造sql查询的时候需要反过来考虑索引
	1.独立的列： 索引列不能是表达式的一部分，也不能是函数的参数 （简化where条件，始终将索引列单独放在比较符号的一侧）
	2.前缀索引和索引选择性： 当需要索引很长的字符列的时候，可以选择索引开始的部分字符（虽然这样会降低索引的选择性，因此需要适当选择索引的长度）
		如何选择合适的索引长度： 
			方法一：先查看完整列的的选择性，然后从一个比较小的长度开始，逐渐增大，当发现选择性比较接近完全列的选择性即可
			方法二：(在数据分布不均匀的时候，该方法可能无效)
				select count(distinct city)/count(*) from sakila.city_demo;(以此结果为基准)
				select count(distinct left（city，3）)/count(*) from sakila.city_demo;
				select count(distinct left（city，4）)/count(*) from sakila.city_demo;
				select count(distinct left（city，5）)/count(*) from sakila.city_demo;
				...
		注意： mysql无法使用前缀索引做order by和group by，也无法使用前缀索引做覆盖扫描
	3.多列索引
		注意： 在多个列上建立独立的单列索引大部分情况下并不能提高mysql的查询性能
		mysql5.0和更新版本引入了一种叫“索引合并”的策略，相当于一种查询优化
		
		如果在EXPLAIN中看到有索引合并（类似下面）
			（Extra: Using union (PRIMAEY, idx_fk_film_id)）;Using where
		说明需要进行多列索引优化
	4.选择合适的索引列顺序
		经验法则： 将选择性最高的列放到索引最前列(通常用于在不需要考虑排序和分组时,在一些场景下可能没有帮助)
		注意： 性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关（即与值的分布有关,因此有时需要根据那些运行频率最高的查询来调整索引列的顺序）
	5.聚簇索引
		是一种数据存储方式，可以理解成是一个“同时保存了B-Tree索引和数据行()”的数据结构
		当表中有聚簇索引时，它的数据行实际上存放在索引的叶子中。（“聚簇”表示数据行和键值存储在一起）
		顺序的主键什么时候会造成更坏的结果？（对于高并发工作负载，可能造成“争夺主键上界”，引发间隙锁竞争；另一个热点可能是“AUTO_INCREMENT”锁机制）
	6.覆盖索引
		覆盖索引的概念： 一个索引包含（或者说覆盖）所有需要查询的字段的值
		当发起一个被索引覆盖的查询时，在EXPLAIN的Extra列可以看到“Using index”的信息
	7.使用索引扫描来做排序
		mysql可以有两种方式可以生成有序的结果： 1.排序操作      2.按索引顺序扫描
		注意 ： 
			1.EXPLAIN出来的“type”值为‘index’时，说明使用了索引扫描来排序
			2.只有当索引的列顺序和ORDER BY 子句的顺序完全一致，并且所有列的排序方向一致时，才能够使用索引来对结果做排序
			3.如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部来自第一张表时，才能使用索引做排序（同时ORDER BY 也需要满足最左前缀的要求）
			4.where 和 order by 中的列可以组成索引的最左前缀时，才可以使用索引排序
	8.冗余和重复索引
		尽量扩展已有的索引，而不是创建新的索引
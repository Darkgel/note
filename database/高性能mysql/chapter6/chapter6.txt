第六章 查询性能优化

查询优化，索引优化，库表结构优化需要齐头并进，一个不落

查询的大致生命周期： 
    从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。

对于低效的查询，可以通过以下两个步骤来分析
    1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列
    2.确认Mysql服务器层是否在分析大量超过需要的数据行

对于mysql，最简单的衡量查询开销的3个指标：
    1.响应时间
    2.扫描的行数
    3.返回的行数



重构查询的方式
    一个复杂查询还是多个简单查询？
        实际上mysql从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效

    切分查询
        eg ： 定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小的但重要的查询。
        此时可以将一个大的DELETE语句切分成多个较小的查询，减少对性能的影响

    分解关联查询
        eg ：
            将原关联查询
                SELECT * FROM tag 
                    JOIN tag_post ON tag_post.tag_id=tag.tag_id
                    JOIN post ON tag_post.post_id=post.post_id
                WHERE tag.tag='mysql'

            分解成
                SELECT * FROM tag FROM tag='mysql';
                SELECT * FROM tag_post WHERE tag_id=1234;
                SELECT * FROM post WHERE post.id in (123,234,345);

        优势：
            1.让缓存的效率更高
            2.将查询分解后，执行单个查询可以减少锁的竞争
            3.在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
            4.查询本身效率也可能会有所提升。例如，使用IN()代替关联查询，可以让mysql 按照id顺序进行查询，比随机的关联高效
            5.可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据
            6.这样做相当于在应用章实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景哈希关联的效率要高很多

        在很多场景下，通过重构查询将关联放到放到应用程序中将会更加高效，比如：
            1.当应用能够方便地缓存单个查询的结果的时候
            2.当可以将数据分布到不同的mysql服务器上的时候
            3.当能够使用in（）的方式代替关联查询的时候
            4.当查询中使用同一个数据表的时候



查询执行的基础
    在mysql的概念中，每个查询都是一次关联，所以读取结果临时表也是一次关联
    当前mysql关联执行的策略很简单：
        mysql对任何关联都执行嵌套循环关联擦操作，即mysql先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行

    无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序


MySQL查询优化器的局限性



查询优化器的提示




优化特定类型的查询
    优化COUNT()查询
        COUNT()的作用：
            1.统计某个列值的数量（要求列值非空，即不统计null），若在COUNT()的括号中指定了列或者列的表达式，则统计的就是这个列有值的结果数
            2.统计行数（当mysql确认括号内的表达式不可能为空时，实际上就是在统计行数）

        MyISAM 的COUNT()非常快，前提是没有带任何where条件


    优化关联查询
        1.确保ON 或者USING子句中的列上有索引。一般来说，除非有其他理由，否则只需要在关联顺序中的第二个表的相应列上创建索引
        2.确保任何的GROUP BY和 ORDER BY中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程
        3.当升级mysql的时候需要注意：关联语法，运算符优先级等其他可能会发生变化的地方。因为以前是普通关联的地方可能会变成笛卡尔积，不同类型的关联可能会生成不同的结果
    

    优化子查询
        尽可能使用关联查询代替

        子查询需要创建和填充临时表，而子查询中创建的临时表是没有任何索引的


    优化GROUP BY 和DISTINCT
        在MySQL中，当无法使用索引的时候，GROUP BY 使用两种策略来完成：
            1.使用临时表来分组
            2.使用文件排序来做分组

        使用标识列来分组效果会更好

    
    优化LIMIT分页
        1.尽可能使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列（延迟关联）
            eg：
                SELECT film_id,description FROM sakila.film ORDER BY title LIMIT 50,5;
                优化后
                SELECT film.film_id,film.description
                FORM sakila.film 
                    INNER JOIN (
                        SELECT film_id FROM sakila.film
                        ORDER BY title LIMIT 50,5
                    ) AS lim USING(film_id)

        2.将limit查询转换为已知位置的查询，让mysql通过范围扫描获得对应的结果
            SELECT film_id,description FROM　sakila.film
            WHERE position BETWEEN 50 AND 54 ORDER BY position

        分页的优化设计
            做法一：将具体的页数换成“下一页”按钮，假设每页显示20条记录，那么每次查询时都是用LIMIT返回21条记录并只显示20条，如果第21条存在，那么就显示“下一页”按钮
            做法二：先获取并缓存较多的数据（例如1000条），然后每次分页都从缓存中获取。这样做可以让应用程序根据结果集的大小采取不同策略，如果结果集少于1000，就可以
                在页面上显示所有的分页连接；如果结果集大于1000，则可以在页面上设计一个额外的“找到的结果多于1000条”之类的按钮。

    优化UNION查询
        Mysql 总是通过创建并填充临时表的方式来执行UNION 查询。除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL。如果没有ALL关键字，mysql会给临时表加上
        DISTINCT选项，导致对整个临时表的数据做唯一性检查





第六章 查询性能优化

查询优化，索引优化，库表结构优化需要齐头并进，一个不落

查询的大致生命周期： 
    从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。

对于低效的查询，可以通过以下两个步骤来分析
    1.确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多的列
    2.确认Mysql服务器层是否在分析大量超过需要的数据行

对于mysql，最简单的衡量查询开销的3个指标：
    1.响应时间
    2.扫描的行数
    3.返回的行数



重构查询的方式
    一个复杂查询还是多个简单查询？
        实际上mysql从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效

    切分查询
        eg ： 定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据，占满整个事务日志，耗尽系统资源，阻塞很多小的但重要的查询。
        此时可以将一个大的DELETE语句切分成多个较小的查询，减少对性能的影响

    分解关联查询
        eg ：
            将原关联查询
                SELECT * FROM tag 
                    JOIN tag_post ON tag_post.tag_id=tag.tag_id
                    JOIN post ON tag_post.post_id=post.post_id
                WHERE tag.tag='mysql'

            分解成
                SELECT * FROM tag FROM tag='mysql';
                SELECT * FROM tag_post WHERE tag_id=1234;
                SELECT * FROM post WHERE post.id in (123,234,345);

        优势：
            1.让缓存的效率更高
            2.将查询分解后，执行单个查询可以减少锁的竞争
            3.在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展
            4.查询本身效率也可能会有所提升。例如，使用IN()代替关联查询，可以让mysql 按照id顺序进行查询，比随机的关联高效
            5.可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据
            6.这样做相当于在应用章实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景哈希关联的效率要高很多

        在很多场景下，通过重构查询将关联放到放到应用程序中将会更加高效，比如：
            1.当应用能够方便地缓存单个查询的结果的时候
            2.当可以将数据分布到不同的mysql服务器上的时候
            3.当能够使用in（）的方式代替关联查询的时候
            4.当查询中使用同一个数据表的时候



查询执行的基础



MySQL查询优化器的局限性



查询优化器的提示




优化特定类型的查询




第五章 创建高性能的索引
B-Tree索引
    B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据

    可以使用B-Tree索引的查询类型。B-Tree索引适用于全键值，键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找

    因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作（按顺序查找）。一般来说，如果B-Tree可以按照某种凡是查找到值，那么也可以按照这种方式用于排序。所以，如果ORDER BY子句满足
    相应的查询类型，则这个索引也可以满足对应的排序需求。（GROUP BY类似）

    如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

哈希索引
    哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。

    哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。

空间数据索引（R-Tree）
    MyISAM表支持空间索引，可以用作地理数据存储。

全文索引
    全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值

索引的三个优点
    1.索引大大减少了服务器需要扫描的数据量
    2.所以可以帮助服务器避免排序和临时表
    3.索引可以将随机I/O变成为顺序I/O

高性能的索引策略
    独立的列
        如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。因此应该简化WHERE条件，始终将索引列单独放在比较符号的一侧
            SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;(无法使用actor_id列的索引)
            SELECT actor_id FROM sakila.actor WHERE actor_id = 4;(可以使用actor_id列的索引)

    前缀索引和索引选择性
        有时候需要索引很长的字符列，这会然索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值（也称为基数）和
        数据包的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择行越高则查询效率越高。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

        一般情况下某个列的前缀的选择性也是足够高的，足以满足查询性能。对于BLOB，TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。
        通常情况，我们应该尽量使前缀的“基数”接近于完整列的“基数”

        前缀索引的缺点 : MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。

    多列索引
        在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。此时应该考虑建立多列索引。

    选择合适的索引列顺序（针对B-Tree索引）
        当不需要考虑排序和分组时，通常将选择性最高的列放到索引最前列。
        有时可能需要根据那些运行频率最高的查询来调整索引列的顺序。

    聚簇索引

    覆盖索引
        如果一个索引包含（或者说是覆盖）所有需要查询的字段的值，我们就称为“覆盖索引”，使用覆盖索引能够极大地提高性能。

    使用索引来做排序
        MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，涉及索引时应该尽可能地同时满足这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所以列的排序方向（倒序或正序）都一样
        时，MySQL才能使用索引来对结果排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀需求；
        否则，MySQL都需要执行排序操作，而无法利用索引排序。

    冗余和重复索引
        重复索引是指在想用地列上按照相同地顺序创建地相同类型地索引，应该避免这样创建地重复索引，发现后也应该立即移除。MySQL允许在相同列上创建多个索引。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能。

        冗余索引和重复索引又一些不同。如果创建了索引（A,B）,再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。大多数情况下，都不需要冗余索引，应该尽可能扩展已有的索引而不是创建新索引。但也有时候
        出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。

    未使用的索引
        若一个索引不再被使用，则应该考虑删除。可以通过一些工具扎到未使用的索引，如Percona Toolkit中的pt-index-usage

    索引和锁


创建索引的一些思考
    1.考虑表上所有的选项（频率，区分度）
    2.应该同时优化查询和索引以找到最佳的平衡，而不是闭门造车去设计最完美的索引
    3.尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列
    4.可以使用IN()的方式覆盖那些不在WHERE子句中的列，但不可滥用，因为每额外增加一个IN()条件，优化器需要做的组合都将以指数的形式增加，最终可能会极大
    地降低查询性能

    优化翻页索引地一个比较号地策略是使用延迟关联，通过使用覆盖索引查询返回需要的索引，在根据这些主键关联原表获得需要的行。这可以减少MySQL扫描那些需要丢弃的行数。
        eg ： 使用（sex，rating）索引进行排序和分页：
            SELECT <cols> FROM profiles INNER JOIN (
                SELECT <primary key cols> FROM profiles
                WHERE x.sex='M' ORDER BY rating LIMIT 100000,10
            ) AS x USING(<primary key cols>);

查询只能使用索引的最左前缀，直到遇到第一个范围条件列。对于范围条件查询，MySQL无法使用范围列后面地其他索引列了。



维护索引和表
    维护表有三个主要的目的：
        1.找到并修复损坏的表
            CHECK TABLE
            REPAIR TABLE
            ALTER TABLE innodb_tbl ENGINE=INNODB;//重建表
        2.维护准确的索引统计信息，
        3.减少碎片


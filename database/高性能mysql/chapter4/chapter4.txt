第四章 Schema与数据类型优化

4.1 选择优化的数据类型
    选择原则
        1.更小的通常更好
            尽量使用可以正确存储数据的最小数据类型

        2.简单就好
            简单数据类型的操作通常需要更少的cpu周期

        3.尽量避免 NULL
            通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。可为NULL的列会使用更多的存储空间，MySQL里也需要特殊处理
            通常把可为NULL 的列改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要在现有schema中查找并修改掉这种情况，除非确定这会导致问题。
            但是，如果计划在列上建索引，就应该避免设计成可为NULL 的列

    如何选择数据类型
        1.确定合适的大类型：数字，字符串，时间等
        2.选择具体类型

    整数类型
        TINYINT(8 bit)， SMALLINT(16 bit), MEDIUMINT(24 bit), INT(32 bit), BIGINT(64 bit)
        可选属性 ： UNSIGNED

        为整数类型指定宽度（INT(11)） 没有限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数

    实数类型
        DECIMAL，FLOAT（4 byte）， DOUBLE（8 byte）
        FLOAT，DOUBLE类型支持使用标准的浮点运算进行近似计算（不精确类型）；DECIMAL类型用于存储精确的小数，支持精确计算（精确类型）

        浮点和DECIMAL类型都可以指定精度。
            DECIMAL列
                可以指定小数点前后所允许的最大位数。MySQL5.0和更高版本将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。
                例如DECIMAL(18,9)小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点占一个字节
                
            浮点列
                有多种方法可以指定浮点列的精度，这些精度定义是非标准的，所以建议只指定数据类型，不指定精度

        因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAl

    字符串类型
        VARCHAR， CHAR， BINARY， VARBINARY

        VARCHAR
            VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于或等于255字节，则使用1个字节表示，否则使用2个字节
            
            下面这些情况适合使用VARCHAR：
                1.字符串列的最大长度比平均长度大很多
                2.列的更新很少，所以碎片不是问题
                3.使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储

        CHAR
            CHAR适合存储很短的字符串，或者所有的值都接近同一个长度。

        二进制字符串（CHAR， VARCHAR）跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符

        VARCHAR(33) 定义的33个字符而不是字节，CHAR类似

    BLOB 和 TEXT类型
        BLOB 和TEXT 都是为了存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储

        字符类型
            TINYTEXT，SMALLTEXT， TEXT， MEDIUMTEXT, LONGTEXT
        二进制类型
            TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB (BLOB是SMALLBLOB的同义词，TEXT是SMALLTEXT的同义词)

        BLOB和TEXT家族之间仅有的不同是BLOB类型存储的是二进制数据，没有排序规则或字符集，而TEXT类型有字符集和排序规则


    使用枚举（ENUM）代替字符串类型

    日期和时间类型
        MySQL能存储的最小时间粒度为秒

        DATETIME, TIMESTAMP

        DATETIME
            范围 ： 从1001年到9999年，精度为妙
            与时区无关，使用8个字节的存储空间（YYYYMMDDHHMMSS）

        TIMESTAMP
            范围 ： 从1970年1月1日午夜（格林尼治时间）以来的秒数，与UNIX时间戳相同
            使用4个字节的存储空间（从1970年到2038年）
            TIMESTAMP显示的值依赖于时区

        除了特殊行为之外，通常也应该尽量使用TIMESTAMP,因为比DATETIME空间效率高。有时候人们会将UNIX时间存储为整数值，但用整数保存时间戳的格式通常不方便处理，故不推荐

    位数据类型
        从技术上来说都是字符串类型
        BIT， SET

        BIT
            MySQL把BIT当作字符串类型，而不是数字类型。当检索BIT(1)的值时，结果是一个包含二进制0或者1的值的字符串，而不是ASCII码的“0”或者“1”
            然而在数字上下文的场景中检索时，结果将是位字符串转换成的数字
            eg ： 存储一个值b'001111001'（二进制的57）到BIT(8)的列并且检索它，得到的内容是字符码为57的字符串(得到ASCII码为57的字符“9”).但是在数字上下文场景中，得到的是数字57

            应该避免使用BIT类型

        SET
            改变列的定义的代价比较高：需要ALTER TABLE

    选择标识符
        标识列(自增长列)，可以不用手动的插入值，系统提供默认的序列值

        尽量使用整数类型

    



4.2 MySQL Schema 设计中的陷阱
    1.太多的列

    2.太多的关联

    3.全能枚举
        防止过度使用枚举

    4.变相的枚举

    5.非此发明（Not Invent Here）的NULL


4.3 范式和反范式
    在范式话的数据库中，每个事实数据会出现并且只出现一次；在反范式化的数据库中，信息是冗余的，可能会存储在多个地方

    范式
        优点：
            1.范式化的更新操作比反范式化要快
            2.当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
            3.范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
            4.很少有多余地数据意味着检索列表数据时更少需要DISTINCT 或者GROUP BY语句。

        缺点：
            1.通常需要关联

    反范式
        优点 ： 
            1.可以避免关联
            2.单独的表可以使用更有效的索引策略

    混用范式与反范式
        最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。（可以使用触发器更新缓存值）

        另一个从父表冗余一些数据到子表的理由是排序的需要




4.4 缓存表和汇总表
    缓存表
        表示存储那些可以比较简单地从schema其他表获取（但是每次获取的速度比较慢）数据的表（例如，逻辑上冗余的数据）

    汇总表
        表示存储的是使用GROUP BY 语句聚合数据的表（例如，数据不是逻辑上冗余的）

    在使用缓存表和汇总表时，必须决定是实时维护数据还是定时重建（依情况而定）；定期重建可以节省资源，可以保持表不会有很多碎片，以及由有完全顺序组织的索引（会更加高效）
    
    当重建汇总表和缓存表时，通常需要保证数据在操作是依然可用。这就需要通过使用“影子表”来实现，“影子表”指的是一张在真实表“背后”创建的表。当完成了建表操作后，可以通过
    一个原子的重命名操作切换影子表和原表。
        eg： 
            DROP TABLE IF EXISTS my_summary_new,my_summary_old
            CREATE TABLE my_summary_new LIKE my_summary;
            -- 往my_summary_new中填充数据
            RENAME TABLE my_summary TO my_summary_old,my_summary_new TO my_summary;

    计数器表
        可以创建一张独立的表存储计数器，这样可以使计数器表小且快。使用独立的表可以帮助避免查询缓存失效


4.5 加快ALTER TABLE 操作的速度
    MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表（因此性能不好，会导致MySQL服务中断）

    对于常见的场景，能使用的技巧只有两种：
        1.先在一台不提供服务的机器上执行执行ALTER TABLE操作，然后和提供服务的主库进行切换
        2.“影子拷贝”：用要求的表结构创建一张和原表无关的新表，然后通过重命名和删表操作交换两张表。



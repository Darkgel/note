# 第二章 InnoDB存储引擎

特点：

- 行锁设计
- 支持mvcc
- 支持外键
- 提供一致性非锁定读

## InnoDB存储引擎的架构

### 后台线程

InnoDB存储引擎是多线程的模型，不同的后台线程负责处理不同的任务

- Master Thread
  - 核心后台线程，主要负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER）,UNDO页的回收（这个可以有Purge Thread来处理）等。
- IO Thread
  - 在InnoDB存储引擎中大量使用了AIO(Async IO)来处理写请求（可以极大提高数据库的性能）。而IO Thread的工作主要是负责这些IO请求的*回调处理(callback)*
- Purge Thread
  - 事务被提交后，其所使用的undolog可能不再需要，因此需要Purge Thread来回收已经使用并分配的undo页。
  - Page Cleaner Thread
    - 将之前版本（InnoDB 1.2.x）中脏页的刷新操作都放入到单独的线程中来完成。

### 内存

InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。

- 缓冲池
  - 一块内存区域。在数据库中进行读取页的操作，首先将从磁盘读到的页存放在缓冲池中，下一次再读相同的页时先判断是否存在于缓冲池中；对于数据库中页的修改操作，则首先修改再缓冲池中的页，然后再以一定的频率刷新到磁盘上（Checkpoint机制）。
  - 缓冲池中缓存的数据页类型：索引页，数据页，undo页，插入缓冲，自适应哈希索引，InndoDB存储的锁信息，数据字典信息等（允许有多个缓冲池实例）。
- LRU List，Free List 和 Flush List
  - 用于对缓冲池的内存区域进行管理(优化的LRU算法)
  - 缓冲池中的页还可能会被分配给自适应哈希索引，lock信息，Insert Buffer等页，而这部分页不需要LRU算法进行维护
  - 在LRU列表中的页被修改后，称该页为脏页，Flush List中的页即为脏页（脏页既存在于LRU列表中，也存在于Flush列表中）
- 重做日志缓冲
  - InnoDB存储引擎首先将重做日志信息放入到这个缓冲区，然后按一定频率将其刷新到重做日志文件

### Checkpoint技术

为了避免数据丢失问题，当前事务数据库系统普遍都采用了Write Ahead Log策略（即当事务提交时先写重做日志，再修改页）。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复（这也是事务中持久性的要求）。

checkpoint技术的目的是解决以下几个问题：

- 缩短数据库的恢复时间
- 缓冲池不够用时，将脏页刷新到磁盘
- 重做日志不可用时，刷新脏页

当数据库发生宕机时，数据库不需要重做所有的日志，因为CheckPoint之前的页都已经刷新回磁盘

checkpoint做的事情：在适当的条件下将缓冲池中的脏页刷回磁盘

### Master Thread 工作方式

即使某个事务没有提交，InnoDB存储引擎任然每秒会将重做日志缓冲中的内容刷新到重做日志文件

Master Thread具有最高的线程优先级别。其内部由多个循环（loop）组成

- 主循环（loop）
- 后台循环（background loop）
- 刷新循环（flush loop）
- 暂停循环（suspend loop）

### InnoDB关键特性

- 插入缓冲（Insert Buffer）
  - Insert Buffer和数据页一样，也是物理页的一个组成部分
  - B+树的特性决定了非聚集索引插入的离散性
  - 对于*非聚集索引*的*插入*或*更新*操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插入；若不在，则先放入到一个Insert Buffer对象中（好似欺骗数据库这个非聚集的索引已经插入到叶子节点）。然后再以一定的频率和情况进行Insert Buffer和辅助索引页子节点的merge操作（这时通常可以将多个插入合并到一个操作中（因为在一个索引页中））
  - 使用Insert Buffer需要满足：1.索引是辅助索引 2.索引不是唯一的
  - Change Buffer，可视为Insert Buffer的升级，包含：Insert Buffer，Delete Buffer，Purge Buffer
  - Insert Buffer的数据结构是一棵B+树
  - 用于提升性能
- 两次写（doublewrite）
  - 用于增强数据页的可靠性
  - 部分写失效（partial page write）：当方发生数据库宕机时，可能InnoDB存储引擎正在写入某个页到表中，而这个页只写了一部分（比如16KB的页只写了前4KB）
  - 在应用重做日志前，用户需要一个页的副本，当写入失效发生时（页本身已经发生损坏），先通过页的副本来还原该页，再进行重做，这就是doublewrite
  - doublewrite由两部分组成，一部分是内存中的doublewrite buffer（2MB），另一部分是物理磁盘上共享表空间中连续的128个页，即2个区（extent），也是2MB
  - 当需要刷新脏页时，先将脏页复制到内存中的doublewirte buffer，然后分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。在完成doublewrite页的写入后，再将doublewrite buffer中的页写入各个表空间文件（此时的写入是离散的）
- 自适应哈希索引（Adaptive Hash Index AHI）
  - InnoDB存储引擎会监控对表上各索引页的查询，根据需要建立哈希索引
  - AHI是通过缓冲池的B+树页构造而来
  - 只能用于搜索等值查询
- 异步IO
  - 采用异步IO提高磁盘操作性能
  - 可以进行IO Merge操作
- 刷新邻接页
  - 当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新
# 第六章 锁

## 什么是锁

- 锁机制用于管理对共享资源的并发访问
- 使用锁的对象：行级别的数据，缓冲池中的LRU列表元素等各种资源

## lock与latch

latch

- 一般称为闩锁（轻量级的锁），因为其要求锁定时间必须非常短
- 在InnoDB中，latch可以分为mutex（互斥量）和rwlock（读写锁）
- 目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制
- 存在于每个数据结构的对象中

lock

- lock的对象是事务，用来锁定的是数据库中的对象（如表，页，行）
- 一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）
- 有死锁机制

## InnoDB存储引擎中的锁（lock）

### 锁的类型

锁的类型（InnoDB中实现了如下两种标准的*行级锁*）

- 共享锁（S Lock），允许事务读取一行数据。
- 排他锁（X Lock），允许事务删除或更新一行数据。


意向锁（Intention Lock）：用于支持在不同粒度上进行加锁操作（例如允许事务在行级上的锁和表级上的锁同时存在），意向锁是将锁定的对象分为多个层次，*意向锁*意味着事务希望在更细粒度上进行加锁

InnoDB中的意向锁比较简练，其意向锁即为*表级别*的锁。设计的目的主要是为了*在一个事务中揭示下一行将被请求的锁类型*。其支持两种意向锁：

- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁

### 一致性非锁定读（consistent nonlocking read）

一致性的非锁定读：指InnoDB存储引擎通过*行多版本控制（multi versioning）*的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB存储引擎回去读取行的一个快照数据。

快照数据是指该行之前的版本的数据，该实现是通过*undo段*来完成（而undo用来在事务中回滚数据，因此快照数据本身是没有额外的开销。同时读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作）。

在InnoDB存储引擎的默认设置下，这是默认的读取方式，即读取不会占用和等待表上的锁。（但是在不同事务隔离级别下，读取的方式不一定就是该方式（READ COMMITTED 和 REPEATABLE READ采用了这个非锁定的一致性读））

*非锁定读机制极大地提高了数据库的并发性*

一个行记录可能有不止一个快照数据，一般称这种技术为*行多版本技术*。由此带来的并发控制，称之为*多版本并发控制（Multi Version Concurrency Control，MVCC）*

- 在READ COMMITTED事务隔离级别下，对于快照数据，非一致性读总是读取*被锁定行*的*最新一份*快照数据（即没有被锁定的话就直接读取行的最新版本）
- 在REPEATABLE READ事务隔离级别下，对于快照数据，非一致性读总是读取事务开始时的行数据版本

*注意：在默认配置下，即事务的隔离级别为REPEATABLE READ模式下，InnoDB存储引擎的SELECT操作使用一致性非锁定读。*

### 一致性锁定读

InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）（必须在一个事务中使用）：

- SELECT ... FOR UPDATE （对行记录加一个X锁）
- SELECT ... LOCK IN SHARE MODE （对行记录加S锁）

*注意：对于一致性非锁定读,即使读取的行已经被执行了SELECT ... FOR UPDATE（或SELECT ... LOCK IN SHARE MODE），也是可以进行读取的*

### 自增长与锁

在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化（通过执行如下语句）

```
SELECT MAX(auto_inc_col) FROM t FOR UPDATE;(这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长插入SQL语句后立即释放)
```

插入操作会依据这个自增长的计数器值加1赋予自增长列

从MySQL5.1.22版本开始，InnoDB存储引擎提供了一种轻量级互斥量（mutex）的自增长实现机制（比上面的性能好）

注意：在InnoDB存储引擎中，自增长值的列必须是索引，同时必须是索引的第一个列。

### 外键和锁

在InnoDB存储引擎中，对于一个外键列，如果没有显式地对这个列加索引，InnoDb存储引擎会自动对其加一个索引（因为这样可以避免表锁）

对于外键值的插入或更新，首先需要查询父表中的记录，即SELECT父表（*不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题*），此时使用的是SELECT ... LOCK IN SHARE MODE 方式


## 锁的算法

InnoDB存储引擎有3种行锁的算法：

- Record Lock ：单个记录行上的锁
- Gap Lock ：间隙锁，锁定一个范围，但不包含记录本身
- Next-Key Lock ：Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身

Record Lock总是会去锁定索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。

采用Next-Key Lock的锁定技术称为Next-Key Locking。*其设计的目的是为了解决Phantom Problem*

然而，当*查询*的索引含有*唯一属性*时，InnoDB存储引擎会对Next-Key Lock进行优化，将其降级为Record Lock

*Gap Lock的作用是为了阻止多个事务将记录插入到同一个范围内，而这会导致Phantom Problem*

### 解决Phantom Problem

在REPEATABLE READ下，InnoDB存储引擎采用Next-Key Locking机制来避免Phantom Problem

Phantom Problem : 在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能返回之前不存在的行。

InnoDB存储引擎默认的事务隔离级别是REPEATABLE READ,在该隔离级别下，其采用Next-Key Locking的方式来加锁。而在READ COMMITTED下，其仅采用Record 

## 锁问题

*通过锁定机制可以实现事务的隔离性要求*，使得食物可以并发地工作。

使用锁会带来的问题（锁相关的问题更准确？）：

- 脏读
  - 脏数据 ： 事务对缓冲池中行记录的修改，*并且还没有提交（commit）*
  - 脏读 ： 在不同的事务下，当前事务可以读到另外事务未提交的数据
  - 在READ UNCOMMITTED隔离级别下会出现脏读
  - 违反了数据库事务的隔离性
- 不可重复读 ： 
  - 在一个事务内多次读取同一数据集，当这个事务未结束时，另外一个事务也访问同一数据集，并做了一些DML操作，因此第一个事务内的两次读到的数据是不一样的
  - 与脏读的区别： 脏读是读到*未提交*的数据，而不可重复读读到的却是*已经提交的数据*
  - 在READ COMMITTED隔离级别下会出现
  - 违反了数据库事务的一致性
  - 在InnoDB中，通过使用*Next-Key Lock*算法来避免不可重复读的问题（MySQL官方称为Phantom Problem 幻像问题）
- 丢失更新
  - 一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致
  - 要避免丢失更新发生，需要让事务的操作变成串行化（使用update语句来加排他锁）

## 死锁

死锁 ： 指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。

解决死锁的方法 ：

- 超时：先超时的事务进行回滚，另一个等待的事务就能继续进行
- wait-for graph（等待图）：进行死锁检测
  - 需要保存两种信息：1.锁的信息链表 2. 事务等待链表
  - 通过上述链表可以构造出一张图，若存在回路，就代表存在死锁，因此资源间相互发生等待
  - 通常InnoDB选择回滚undo量最小的事务
  - wait-for graph的死锁检测通常采用深度优先的算法实现

*InnoDB并不会回滚大部分的错误异常，但是死锁除外。发现死锁后，InnoDB会马上回滚一个事务*

## 锁升级（Lock Escalation）

锁升级指将当前锁的粒度降低（从低到高：表锁->页锁->行锁）

InnoDB中不存在锁升级的问题。因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理，采用的是位图的方式。
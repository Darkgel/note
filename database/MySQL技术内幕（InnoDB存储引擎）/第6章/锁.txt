第六章 锁
    

6.1 什么是锁
    锁的存在是为了在并发访问的时候能够以一致的方式读取和修改数据

    锁机制用于管理对共享资源的并发访问

    锁帮助实现了事务的隔离性。


6.2 lock与latch
    latch一般成为闩锁（轻量级的锁），其要求锁定的时间必须非常短，可分为：
        1. mutex(互斥量)
        2. rwlock（读写锁）

        其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制

    lock
        lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行
        一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）
        有死锁检测机制

    看图 ： ./lock与latch的比较


6.3 InnoDB存储引擎中的锁
    InnoDB存储引擎实现了如下两种标准的行级锁：
        1. 共享锁（S Lock），允许事务读一行数据
        2. 排他锁（X lock）， 允许事务删除或更新一行数据

    InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。
    意向锁（Intention Lock） ： 为了支持在不同粒度上进行加锁操作，引入该锁
        为了对细粒度的对象上锁，需要先对粗粒度的对象上锁
        如果需要对页上的记录r进行上X锁，那么分别需要对数据库A，表，页上意向锁IX，最后对记录r上X锁。

        InnoDB中的意向锁为表级别的锁
        由于InnoDB支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求

        1. 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁
        2. 意向排他锁（IX Lock）， 事务想要获得一张表中某几行的排他锁

    一致性非锁定读（consistent nonlocking read）
        指InnoDB存储引擎通过多版本控制（multi versioning）的方式来读取当前执行时间数据库中的数据。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。
        相反地，InnoDB存储引擎回去读取行的一个快照数据。

        在InnoDB的默认设置下，这是默认的读取方式（一致性非锁定读）。但是在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都是采用非锁定的一致性读。

        即使都是采用一致性非锁定读，在不同的隔离级别下，对于快照数据（MVCC，多版本并发控制）的定义也不一样


    一致性锁定读
        InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读（locking read）操作：
            1. SELECT ... FOR UPDATE （加X锁）
            2. SELECT ... LOCK IN SHARE MODE （加S锁）

    自增长与锁
        在InnoDB的内存结构中，对每个含有自增长值的表都有一个自增长计数器。当对含有自增长的计数器的表进行插入操作时，这个计数器会被初始化，执行如下的语句来得到计数器的值：
            SELECT MAX(auto_inc_col) FROM t FOR UPDATE;//加X锁
            这其实是一个特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的sql语句后立即释放。


        新的自增长实现方式
            有点复杂。。。

    外键和锁
        对于外键值的插入或更新，首先需要查询父表中的记录，即select父表。
        但是对父表的select操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，
        因此此时使用的是 ： SELECT ... LOCK IN SHARE MODE 



6.4 锁的算法
    InnoDB有3中行锁的算法 ：    
        1. Record Lock : 单个行记录上的锁
        2. Gap Lock： 锁定一个范围，但不包含记录本身
        3. Next-Key Lock ： Gap Lock + Record Lock，锁定一个范围，并且锁定记录本身   eg ： (2, 8]

        Next-Key Lock降级为Record Lock仅在查询的列是唯一索引的情况下。

    Phantom Problem(幻想问题)
        在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

        InnoDB采用Next-Key Locking算法避免Phantom Problem

        InnoDB默认的事务隔离级别是REPEATABLE READ，在该隔离级别下，其采用Next-Key Locking的方式来加锁
        在事务隔离级别READ COMMITTED下，其仅采用Record Lock。


6.5 锁问题（锁导致的问题）
    1. 脏读
        脏数据 ： 事务对缓冲池中行记录的修改，并且还没有被提交
        脏读 ： 在不同的事务下，当前事务可以读到另外事务未提交的数据。

        脏读发生的条件是 ： 事务的隔离级别为 READ UNCOMMITTED
    
    2. 不可重复读（即Phantom Problem）
        一个事务内两次读到的数据不一样。
        重点 ： 脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据。（在 READ COMMITTED下会出现）

        一般来说，不可重复读的问题是可以接受的，因为其读到的是已经提交的数据。
        在InnoDB中使用Next-Key算法来避免该问题。

    3. 丢失更新
        一个事务的更新操作会被另一个事务的更新操作所覆盖

        要避免丢失更新发生，需要使事务串行化



6.6 阻塞


6.7 死锁
    死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。

    解决死锁问题 ： 
        1. 超时 ：等待超时的事务进行回滚。则另一个就能继续进行。
        2. wait-for graph（等待图） ： 


6.8 锁升级
    指将当前锁的粒度降低。

    eg ： 数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁



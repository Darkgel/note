对于那些只有一组消费者的消息队列，使用redis比较简单。
由于redis的消息队列不是专业的消息队列，没有非常多的高级特性，没有ack保证，如果对消息的可靠性有着极高要求，那么它就不适合使用

redis的list数据结构常用来作为异步消息队列使用。它可以支持多个生产者和多个消费者并发进出消息，每个消费者拿到的消息都是不同的列表元素

空队列的处理
    如果队列空了，客户端就会陷入pop的死循环，拉高了cpu和redis的qps消耗

    解决方法
        1.让线程sleep一段时间（eg ： 1s）
            会导致的问题 ： 导致消息的延迟增大

        2. 使用阻塞读
            阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。
            使用blpop/prpop代替lpop/rpop

            会导致的问题：
                如果线程一直阻塞，redis的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接
                这时候blpop/brpop就会抛出异常

                解决方法：捕获异常，然后重试


锁冲突处理
    处理加锁失败：  
        1. 直接抛出异常，通知用户稍后重试
        2. sleep一会，然后重试
        3. 将请求转移至延时队列，过一会再试


延时队列的实现
    通过redis 的 zset 来实现
    将消息序列化成一个字符串作为zset的value，这个消息的到处处理时间作为score，然后用多个线程轮询
    zset获取到期的任务进行处理（需要判断zrem是否执行成功了，执行成功才代表抢到了任务）
